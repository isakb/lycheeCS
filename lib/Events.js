// Generated by CoffeeScript 1.6.3
(function() {
  lychee.define("Events").exports(function(lychee, global) {
    var Class, Events, _id;
    _id = 0;
    return Class = Events = (function() {
      function Events(_namespace) {
        this._namespace = _namespace;
        _id += 1;
        this._parents = [];
        this._children = [];
        this._events = {};
        this._eventsLength = 0;
        this._id = _id;
        this._callerId = 0;
      }

      Events.prototype.subscribe = function(object, as) {
        if (!object instanceof Class) {
          return false;
        }
        as = (as === "child" ? "child" : "parent");
        if (as === "child") {
          this._children.push(object);
          return true;
        } else if (as === "parent") {
          this._parents.push(object);
          return true;
        }
        return false;
      };

      Events.prototype.unsubscribe = function(object, as) {
        var entry, found, i, l, list;
        if (!object instanceof Class) {
          return false;
        }
        as = (as === "child" ? "child" : "parent");
        list = (as === "child" ? this._children : this._parents);
        found = false;
        i = 0;
        l = list.length;
        while (i < l) {
          entry = list[i];
          if (entry === object) {
            found = true;
            list.splice(i, 1);
            l--;
          }
          i++;
        }
        if (found === true) {
          return true;
        } else {
          return false;
        }
      };

      Events.prototype.bind = function(type, callback, scope, once) {
        var parents, passSelf;
        passSelf = false;
        if (type.substr(0, 1) === "#") {
          type = type.substr(1, type.length - 1);
          passSelf = true;
        }
        if (this._events[type] === void 0) {
          this._events[type] = [];
        }
        parents = type.match(/\./g);
        return this._events[type].push({
          parents: (parents !== null ? parents.length : 0),
          callback: callback,
          scope: scope || global,
          passSelf: passSelf,
          once: once || false,
          at: this._callerId
        });
      };

      Events.prototype.unbind = function(type, callback, scope) {
        var entry, found, i, l;
        callback = (callback instanceof Function ? callback : null);
        scope = (scope !== void 0 ? scope : null);
        if (this._events[type] === void 0) {
          return true;
        }
        found = false;
        i = 0;
        l = this._events[type].length;
        while (i < l) {
          entry = this._events[type][i];
          if ((callback === null || entry.callback === callback) && (scope === null || entry.scope === scope)) {
            found = true;
            this._events[type].splice(i, 1);
            l--;
          }
          i++;
        }
        if (found === true) {
          return true;
        } else {
          return false;
        }
      };

      Events.prototype.trigger = function(type, data, direction) {
        direction = (direction !== void 0 ? direction : true);
        if (data === void 0) {
          data = [];
        }
        if (data._origin === void 0) {
          data._origin = this._id;
        }
        if (data._handled === void 0) {
          data._handled = {};
        }
        if (data._handled[this._id] === true) {
          return null;
        }
        if (direction === true && this._triggerChildren(type, data, direction) === true) {
          return true;
        }
        if (this._trigger(type, data) === true) {
          return true;
        }
        if (direction !== false && direction !== null && this._triggerParents(type, data, direction) === true) {
          return true;
        }
        return false;
      };

      Events.prototype._trigger = function(type, data) {
        var blocked, entry, i, l, passData;
        blocked = false;
        if (data !== void 0) {
          data._handled[this._id] = true;
        }
        this._callerId++;
        if (this._events[type] !== void 0) {
          passData = data;
          i = 0;
          l = this._events[type].length;
          while (i < l) {
            entry = this._events[type][i];
            if (entry.at >= this._callerId) {
              continue;
            }
            if (entry.passSelf === true) {
              passData = [this];
              passData.push.apply(passData, data);
            }
            if (entry.callback.apply(entry.scope, passData) === true) {
              blocked = true;
            }
            if (entry.once === true) {
              this.unbind(type, entry.callback, entry.scope);
            }
            i++;
          }
        }
        if (blocked === true) {
          return true;
        } else {
          return false;
        }
      };

      Events.prototype._triggerChildren = function(type, data, direction) {
        var blocked, child, i, l;
        blocked = false;
        i = 0;
        l = this._children.length;
        while (i < l) {
          child = this._children[i];
          if (child.trigger(type, data, direction) === true) {
            blocked = true;
          }
          i++;
        }
        if (blocked === true) {
          return true;
        } else {
          return false;
        }
      };

      Events.prototype._triggerParents = function(type, data, direction) {
        var blocked, i, l, newData, parent;
        blocked = false;
        if (this._parents.length > 0) {
          newData = [this];
          newData.push.apply(newData, data);
          newData._origin = (data ? data._origin : null);
          newData._handled = (data ? data._handled : null);
          i = 0;
          l = this._parents.length;
          while (i < l) {
            parent = this._parents[i];
            if (parent._id === data._origin) {
              continue;
            }
            if (parent.trigger(this._namespace + "." + type, newData, direction) === true) {
              blocked = true;
            }
            i++;
          }
        }
        if (blocked === true) {
          return true;
        } else {
          return false;
        }
      };

      return Events;

    })();
  });

}).call(this);
