// Generated by CoffeeScript 1.6.3
(function() {
  lychee.define("Track").tags({
    platform: "html"
  }).supports(function(lychee, global) {
    if (global.Audio) {
      return true;
    }
    return false;
  }).exports(function(lychee, global) {
    var AdvancedAudioApi, BasicAudioApi, Track, apiPrototype, d, data, ext, name, prop, _audio, _codecs, _context, _i, _mime, _ref, _supportedFormats;
    _mime = {
      "3gp": ["audio/3gpp"],
      "aac": ["audio/aac", "audio/aacp"],
      "amr": ["audio/amr"],
      "caf": ["audio/x-caf", "audio/x-aiff; codecs=\"IMA-ADPCM, ADPCM\""],
      "m4a": ["audio/mp4; codecs=mp4a"],
      "mp3": ["audio/mpeg"],
      "mp4": ["audio/mp4"],
      "ogg": ["application/ogg", "audio/ogg", "audio/ogg; codecs=theora, vorbis"],
      "wav": ["audio/wave", "audio/wav", "audio/wav; codecs=\"1\"", "audio/x-wav", "audio/x-pn-wav"],
      "webm": ["audio/webm", "audio/webm; codecs=vorbis"]
    };
    _audio = null;
    _context = null;
    if (global.Audio) {
      _audio = new Audio();
      if (global.AudioContext) {
        _context = new AudioContext();
      } else {
        if (global.webkitAudioContext) {
          _context = new webkitAudioContext();
        }
      }
    }
    _codecs = {};
    if (_audio !== null) {
      for (ext in _mime) {
        data = _mime[ext];
        for (d = _i = 0, _ref = data.length; 0 <= _ref ? _i < _ref : _i > _ref; d = 0 <= _ref ? ++_i : --_i) {
          if (_audio.canPlayType(data[d])) {
            _codecs[ext] = data[d];
          } else {
            if (_codecs[ext] === void 0) {
              _codecs[ext] = false;
            }
          }
        }
      }
    }
    _supportedFormats = [];
    for (ext in _codecs) {
      if (_codecs[ext] !== false) {
        _supportedFormats.push(ext);
      }
    }
    if (lychee.debug === true) {
      console.log("lychee.Track: Supported media formats are " + _supportedFormats.join(", "));
    }
    Track = (function() {
      function Track(id, settings, isReady) {
        var f, format, l, playableFormat;
        isReady = (isReady === true ? true : false);
        if (_audio === null) {
          throw "Your Browser does not support HTML5 Audio.";
        }
        this.id = id;
        this.settings = lychee.extend({}, this.defaults, settings);
        this._endTime = 0;
        this._isIdle = true;
        this._isLooping = false;
        this._isMuted = false;
        this._isReady = isReady;
        playableFormat = null;
        f = 0;
        l = this.settings.formats.length;
        while (f < l) {
          format = this.settings.formats[f];
          if (playableFormat === null && _codecs[format] !== false) {
            playableFormat = format;
          }
          f++;
        }
        if (playableFormat === null) {
          throw "Your Environment does only support these codecs: " + _supportedFormats.join(", ");
        } else {
          this._init(this.settings.base + "." + playableFormat);
        }
      }

      return Track;

    })();
    AdvancedAudioApi = (function() {
      function AdvancedAudioApi() {}

      AdvancedAudioApi.prototype.defaults = {
        base: null,
        buffer: null,
        formats: []
      };

      AdvancedAudioApi.prototype._init = function(url) {
        var that, xhr;
        this._context = _context;
        this._gain = this._context.createGainNode();
        this._loopingBuffer = null;
        if (this.settings.buffer === null) {
          that = this;
          xhr = new XMLHttpRequest();
          xhr.open("GET", url);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            return that._context.decodeAudioData(xhr.response, function(buffer) {
              that.settings.buffer = buffer;
              return that._isReady = true;
            });
          };
          return xhr.send();
        } else {
          return this._isReady = true;
        }
      };

      AdvancedAudioApi.prototype.play = function(loop_) {
        var source;
        loop_ = (loop_ === true ? true : false);
        if (this._isReady === true) {
          source = this._context.createBufferSource();
          source.buffer = this.settings.buffer;
          source.connect(this._gain);
          source.connect(this._context.destination);
          source.noteOn(this._context.currentTime);
          if (loop_ === true) {
            source.loop = loop_;
            this._loopingBuffer = source;
            this._endTime = Infinity;
          } else {
            this._endTime = Date.now() + (source.buffer.duration * 1000);
          }
          this._isIdle = false;
          return this._isLooping = loop_;
        }
      };

      AdvancedAudioApi.prototype.stop = function() {
        this._isIdle = true;
        this._isLooping = false;
        if (this._loopingBuffer !== null) {
          this._loopingBuffer.disconnect(this._gain);
          this._loopingBuffer.disconnect(this._context.destination);
          return this._loopingBuffer = null;
        }
      };

      AdvancedAudioApi.prototype.pause = function() {
        this._wasLoopingBeforePause = this._isLooping;
        return this.stop();
      };

      AdvancedAudioApi.prototype.resume = function() {
        return this.play(this._wasLoopingBeforePause);
      };

      AdvancedAudioApi.prototype.mute = function() {
        if (this._isMuted === false) {
          this._unmuteVolume = this._gain.gain.value;
          this._gain.gain.value = 0;
          return this._isMuted = true;
        }
      };

      AdvancedAudioApi.prototype.unmute = function() {
        if (this._isMuted === true) {
          this._gain.gain.value = this._unmuteVolume || 1;
          return this._isMuted = false;
        }
      };

      AdvancedAudioApi.prototype.clone = function() {
        var id, settings;
        id = this.id;
        settings = lychee.extend({}, this.settings);
        return new lychee.Track(id, settings, this._isReady);
      };

      AdvancedAudioApi.prototype.isIdle = function() {
        if (Date.now() > this._endTime) {
          this._isIdle = true;
        }
        return this._isIdle;
      };

      AdvancedAudioApi.prototype.isMuted = function() {
        return this._isMuted;
      };

      AdvancedAudioApi.prototype.isReady = function() {
        return this.isIdle() && this._isReady;
      };

      AdvancedAudioApi.prototype.getVolume = function() {
        return this._gain.gain.value;
      };

      AdvancedAudioApi.prototype.setVolume = function(volume) {
        var newVolume;
        newVolume = Math.min(Math.max(0, volume), 1);
        return this._gain.gain.value = newVolume;
      };

      return AdvancedAudioApi;

    })();
    BasicAudioApi = (function() {
      function BasicAudioApi() {}

      BasicAudioApi.prototype.defaults = {
        base: null,
        formats: []
      };

      BasicAudioApi.prototype._init = function(url) {
        var that;
        this._audio = new Audio(url);
        this._audio.autobuffer = true;
        this._audio.preload = true;
        this._audio.load();
        that = this;
        this._audio.addEventListener("ended", (function() {
          return that._onEnd();
        }), true);
        if (this._isReady === false) {
          this._audio.addEventListener("canplaythrough", (function() {
            return that._isReady = true;
          }), true);
          return setTimeout((function() {
            return that._isReady = true;
          }), 500);
        }
      };

      BasicAudioApi.prototype._onEnd = function() {
        if (this._isLooping === true) {
          this.play(true);
          return false;
        } else {
          this._isIdle = true;
          return true;
        }
      };

      BasicAudioApi.prototype._resetPointer = function() {
        try {
          return this._audio.currentTime = 0;
        } catch (_error) {}
      };

      BasicAudioApi.prototype.play = function(loop_) {
        loop_ = (loop_ === true ? true : false);
        if (this._isReady === true) {
          this._resetPointer();
          this._audio.play();
          this._endTime = Date.now() + (this._audio.duration * 1000);
          this._isIdle = false;
          return this._isLooping = loop_;
        }
      };

      BasicAudioApi.prototype.stop = function() {
        this._isIdle = true;
        this._isLooping = false;
        this._audio.pause();
        return this._resetPointer();
      };

      BasicAudioApi.prototype.pause = function() {
        return this._audio.pause();
      };

      BasicAudioApi.prototype.resume = function() {
        return this._audio.play();
      };

      BasicAudioApi.prototype.mute = function() {
        if (this._isMuted === false) {
          this._unmuteVolume = this._audio.volume;
          this._audio.volume = 0;
          return this._isMuted = true;
        }
      };

      BasicAudioApi.prototype.unmute = function() {
        if (this._isMuted === true) {
          this._audio.volume = this._unmuteVolume || 1;
          return this._isMuted = false;
        }
      };

      BasicAudioApi.prototype.clone = function() {
        var id, settings;
        id = this.id;
        settings = lychee.extend({}, this.settings);
        return new lychee.Track(id, settings, true);
      };

      BasicAudioApi.prototype.isIdle = function() {
        if (Date.now() > this._endTime) {
          return this._onEnd();
        }
        if (this._audio.currentTime >= this._audio.duration) {
          return this._onEnd();
        }
        return this._isIdle;
      };

      BasicAudioApi.prototype.isMuted = function() {
        return this._isMuted;
      };

      BasicAudioApi.prototype.isReady = function() {
        return this.isIdle() && this._isReady === true;
      };

      BasicAudioApi.prototype.getVolume = function() {
        return this._audio.volume;
      };

      BasicAudioApi.prototype.setVolume = function(volume) {
        var newVolume;
        newVolume = Math.min(Math.max(0, volume), 1);
        return this._audio.volume = newVolume;
      };

      return BasicAudioApi;

    })();
    apiPrototype = _context !== null ? AdvancedAudioApi.prototype : _audio !== null ? BasicAudioApi.prototype : {};
    for (name in apiPrototype) {
      prop = apiPrototype[name];
      Track.prototype[name] = prop;
    }
    return Track;
  });

}).call(this);
